#include "gtest/gtest.h"

#include "amf.hpp"
#include "types/amfstring.hpp"

template <size_t N>
static void isEqual(u8 (&expected)[N], std::string value) {
	ASSERT_EQ(make_vector(expected), AmfString(value).serialize()) << "Failed to encode " << value;
}

TEST(StringSerializationTest, EmptyString) {
	u8 v[] = { 0x06, 0x01 };
	isEqual(v, "");
}

TEST(StringSerializationTest, Ascii) {
	u8 v1[] = { 0x06, 0x07, 0x62, 0x61, 0x72 };
	isEqual(v1, "bar");
	u8 v2[] = { 0x06, 0x0D, 0x62, 0x6F, 0x6F, 0x66, 0x61, 0x72 };
	isEqual(v2, "boofar");
	u8 v3[] = { 0x06, 0x07, 0x71, 0x75, 0x78 };
	isEqual(v3, "qux");
	u8 v4[] = { 0x06, 0x07, 0x71, 0x75, 0x7A };
	isEqual(v4, "quz");
	u8 v5[] = { 0x06, 0x09, 0x71, 0x75, 0x75, 0x78 };
	isEqual(v5, "quux");
	u8 v6[] = { 0x06, 0x07, 0x22, 0x27, 0x5C };
	isEqual(v6, "\"'\\");
}

TEST(StringSerialization, MultiByteLength) {
	u8 v[] = { 0x06, 0x84, 0x59, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		           0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		           0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		           0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		           0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		           0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		           0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		           0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		           0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		           0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		           0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		           0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		           0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		           0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		           0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		           0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		           0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		           0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		           0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		           0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		           0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		           0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		           0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		           0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		           0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		           0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		           0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		           0x61, 0x61, 0x61, 0x61, 0x61, 0x61 };
	isEqual(v, std::string(300, 'a'));
}

TEST(StringSerializationTest, Umlaute) {
	u8 v[] = { 0x06, 0x17, 0xC3, 0xBC, 0x6D, 0x6C, 0xC3, 0xA4, 0xC3, 0xBC, 0x74,
		           0xC3, 0xAB };
	isEqual(v, "ümläütë");
}

TEST(StringSerializationTest, Unicode) {
	u8 v1[] = { 0x06, 0x29, 0xC4, 0xA7, 0xC4, 0xB8, 0xC3, 0xB0, 0x40, 0xC3, 0xBE,
		           0xC3, 0xA6, 0xC4, 0xB8, 0xC5, 0xBF, 0xE2, 0x80, 0x9C, 0xC3, 0xB0
		         };
	isEqual(v1, "ħĸð@þæĸſ“ð");
	u8 v2[] = { 0x06, 0x59, 0xE2, 0x80, 0x9D, 0x5D, 0xC2, 0xB2, 0xC2, 0xB3, 0xC2,
		           0xB6, 0xC5, 0xA7, 0xE2, 0x86, 0x93, 0xC3, 0xB8, 0xC4, 0xA7, 0xE2,
		           0x80, 0x9D, 0xE2, 0x80, 0x9C, 0xC5, 0x82, 0xC2, 0xB5, 0xC3, 0xA6,
		           0xC3, 0xB0, 0xC2, 0xB5, 0xE2, 0x86, 0x92, 0xC2, 0xB3, 0xC3, 0xB8,
		           0xC4, 0xA7 };
	isEqual(v2, "”]²³¶ŧ↓øħ”“łµæðµ→³øħ");
}
